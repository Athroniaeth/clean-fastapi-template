from typing import Optional

from sqlalchemy import select, update, Column, Integer, String, Boolean, DateTime, func

from rename.domain.api_keys import (
    ApiKey,
)
from rename.infrastructure.database.base import Base, AbstractDatabaseInfra


class ApiKeyModel(Base):
    __tablename__ = "api_keys"

    id_ = Column(
        Integer,
        primary_key=True,
        autoincrement=True,
    )
    name = Column(
        String(64),
        nullable=False,
    )
    description = Column(
        String(255),
        nullable=True,
    )
    is_active = Column(
        Boolean,
        default=True,
        nullable=False,
    )
    created_at = Column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )

    hashed_key = Column(
        String(128),
        nullable=False,
        unique=True,
    )


def to_domain(row: ApiKeyModel) -> ApiKey:
    """
    Convert an ApiKeyModel instance to a domain ApiKey instance.

    Args:
        row (ApiKeyModel): The SQLAlchemy model instance.

    Returns:
        ApiKey: The domain model instance.
    """
    return ApiKey.model_validate(row)


def to_row(api_key: ApiKey) -> ApiKeyModel:
    """
    Convert a domain ApiKey instance to an ApiKeyModel instance.

    Args:
        api_key (ApiKey): The domain model instance.

    Returns:
        ApiKeyModel: The SQLAlchemy model instance.
    """
    return ApiKeyModel(
        id_=api_key.id_,
        name=api_key.name,
        description=api_key.description,
        is_active=api_key.is_active,
        hashed_key=api_key.hashed_key,
    )


class APIKeyRepository:
    """
    Concrete repository for managing ApiKeyModel persistence with SQLAlchemy.
    """

    def __init__(self, infra_database: AbstractDatabaseInfra) -> None:
        self._infra = infra_database

    async def get_by_id(self, id_: int) -> Optional[ApiKey]:
        """
        Retrieve an ApiKey by its integer ID.

        Args:
            id_ (int): primary key of the API key record.

        Returns:
            Optional[ApiKey]: the matching instance, or None if not found.
        """
        async with self._infra.get_session() as session:
            stmt = select(ApiKeyModel).where(ApiKeyModel.id_ == id_)
            result = await session.execute(stmt)
            row = result.scalar_one_or_none()

            if row is None:
                return None

            return to_domain(row)

    async def get_by_name(self, name: str) -> Optional[ApiKey]:
        """
        Retrieve an ApiKey by its name field.

        Args:
            name (str): the human-readable name of the API key.

        Returns:
            Optional[ApiKey]: the matching instance, or None if not found.
        """
        async with self._infra.get_session() as session:
            stmt = select(ApiKeyModel).where(ApiKeyModel.name == name)
            result = await session.execute(stmt)
            row = result.scalar_one_or_none()

            if row is None:
                return None

            return to_domain(row)

    async def get_by_hashed_key(self, hashed_key: str) -> Optional[ApiKey]:
        """
        Retrieve an ApiKey by its hashed key value.

        Args:
            hashed_key (str): the bcrypt-hashed API key string.

        Returns:
            Optional[ApiKey]: the matching instance, or None if not found.
        """
        async with self._infra.get_session() as session:
            stmt = select(ApiKeyModel).where(ApiKeyModel.hashed_key == hashed_key)
            result = await session.execute(stmt)
            row = result.scalar_one_or_none()

            if row is None:
                return None

            return to_domain(row)

    async def list_all(
        self,
        skip: int = 0,
        limit: int = 100,
        active_only: bool = False,
    ) -> list[ApiKey]:
        """
        List ApiKey records, with optional pagination and active filtering.

        Args:
            skip (int): number of records to skip (for pagination).
            limit (int): maximum number of records to return.
            active_only (bool): if True, only return records where is_active == True.

        Returns:
            Sequence[ApiKey]: list of ApiKey instances.
        """
        async with self._infra.get_session() as session:
            stmt = select(ApiKeyModel)

            if active_only:
                stmt = stmt.where(ApiKeyModel.is_active.is_(True))

            stmt = stmt.offset(skip).limit(limit)
            result = await session.execute(stmt)
            rows = result.scalars().all()

            return [to_domain(row) for row in rows]

    async def create(self, api_key: ApiKey) -> ApiKey:
        """
        Insert a new ApiKey into the database.

        Args:
            api_key (ApiKey): the instance to persist, with fields like name, description, and is_active.

        Returns:
            ApiKey: the persisted instance, with autogenerated fields populated
        """
        row = to_row(api_key)

        async with self._infra.get_session() as session:
            # Add to the session and flush so that autogenerated IDs are populated
            session.add(row)

            await session.commit()
            await session.flush()

            # Update attr like id after commit
            new_api_key = to_domain(row)
            api_key.id_ = new_api_key.id_
            return api_key

    async def update(self, api_key: ApiKey) -> bool:
        """
        Update fields of an existing ApiKey.

        Args:
            api_key (ApiKey): the instance to update.

        Returns:
            bool: True if the update was successful, False otherwise.
        """
        async with self._infra.get_session() as session:
            stmt = (
                update(ApiKeyModel)
                .where(ApiKeyModel.id_ == api_key.id_)
                .values(
                    name=api_key.name,
                    description=api_key.description,
                    is_active=api_key.is_active,
                )
            )
            result = await session.execute(stmt)
            await session.commit()

        # rowcount is bad typed by SQLAlchemy, so we use type: ignore
        return result.rowcount > 0  # type: ignore

    async def delete(self, api_key: ApiKey) -> bool:
        """
        Permanently remove an ApiKey from the database.

        Args:
            api_key (ApiKey): the instance to remove.
        """
        async with self._infra.get_session() as session:
            stmt = select(ApiKeyModel).where(ApiKeyModel.id_ == api_key.id_)
            result = await session.execute(stmt)
            model = result.scalar_one_or_none()

            if model is None:
                return False

            await session.delete(model)
            await session.flush()
            return True
