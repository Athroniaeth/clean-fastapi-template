from typing import Optional, Sequence

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from template.models.users import UserModel  # Import here to avoid circular import


class UserRepository:
    """Repository for user-related database operations."""

    _session: AsyncSession

    def __init__(self, session: AsyncSession):
        self._session = session

    async def get(self, id_: int) -> Optional[UserModel]:
        """
        Retrieve an UserModel by its integer ID.

        Args:
            id_ (int): primary key of the user record.

        Returns:
            Optional[UserModel]: the matching instance, or None if not found.
        """
        stmt = select(UserModel).where(UserModel.id == id_)
        result = await self._session.execute(stmt)
        return result.scalar_one_or_none()

    async def get_by_username(self, username: str) -> Optional[UserModel]:
        """
        Retrieve an UserModel by its name field.

        Args:
            username (str): the human-readable name of the user.

        Returns:
            Optional[UserModel]: the matching instance, or None if not found.
        """
        stmt = select(UserModel).where(UserModel.username == username)
        result = await self._session.execute(stmt)
        return result.scalar_one_or_none()

    async def list_all(self, skip: int = 0, limit: int = 100) -> Sequence[UserModel]:
        """
        List UserModel records, with optional pagination and active filtering.

        Args:
            skip (int): number of records to skip (for pagination).
            limit (int): maximum number of records to return.

        Returns:
            Sequence[UserModel]: list of UserModel instances.
        """
        stmt = select(UserModel)
        stmt = stmt.offset(skip).limit(limit)
        result = await self._session.execute(stmt)
        return result.scalars().all()

    async def create(self, user: UserModel) -> UserModel:
        """
        Insert a new UserModel into the database.

        Args:
            user (UserModel): the new user instance to persist.

        Returns:
            UserModel: the persisted instance, with autogenerated fields populated
        """
        # Add to the session and flush so that autogenerated IDs are populated
        self._session.add(user)
        await self._session.commit()
        return user

    async def update(self, user: UserModel, data: dict) -> bool:
        """
        Update fields of an existing UserModel.

        Args:
            user (UserModel): the instance to update.
            data (dict): dictionary of fields to modify.

        Returns:
            bool: True if the update was successful, False otherwise.
        """
        stmt = update(UserModel).where(UserModel.id == user.id).values(**data)

        result = await self._session.execute(stmt)
        await self._session.commit()
        await self._session.flush()

        # rowcount is bad typed by SQLAlchemy, so we use type: ignore
        return result.rowcount > 0  # type: ignore

    async def delete(self, user: UserModel) -> None:
        """
        Permanently remove an UserModel from the database.

        Args:
            user (UserModel): the instance to remove.
        """
        await self._session.delete(user)
        await self._session.flush()
