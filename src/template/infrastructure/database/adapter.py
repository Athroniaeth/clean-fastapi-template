from __future__ import annotations

from abc import ABC
from typing import Any, Dict, Generic, Optional, Sequence, Type, TypeVar, Protocol, Union

from sqlalchemy import delete, select, update, Column, UUID

from template.infrastructure.database.base import AbstractDatabaseInfra

Id = Union[int, UUID]


class GenericBase(Protocol):
    """Protocol for SQLAlchemy models with a required primary key attribute."""

    id: Column[Id]


T = TypeVar("T", bound=GenericBase)


class AbstractCRUDRepository(Generic[T], ABC):
    """
    Abstract repository providing asynchronous CRUD operations for a given SQLAlchemy model.
    Relies on AbstractDatabaseInfra for session lifecycle and transactional integrity.
    """

    def __init__(self, infra: AbstractDatabaseInfra, model: Type[T]) -> None:
        """
        Initialize the repository with the given database infrastructure and model.

        Args:
            infra (AbstractDatabaseInfra): The database infrastructure instance.
            model (Type[T]): The SQLAlchemy model class to operate on.
        """
        self._infra = infra
        self._model = model

    async def get(self, id_: Id) -> Optional[T]:
        """
        Retrieve a single record by its primary key.

        Args:
            id_ (Id): The primary key of the record.

        Returns:
            Optional[T]: The matched instance or None if not found.
        """
        async with self._infra.session() as session:
            stmt = select(self._model).where(self._model.id == id_)
            result = await session.execute(stmt)
            return result.scalar_one_or_none()

    async def list(self, skip: int = 0, limit: int = 100) -> Sequence[T]:
        """
        Retrieve a paginated list of records.

        Args:
            skip (int): Number of records to skip (default is 0).
            limit (int): Maximum number of records to return (default is 100).

        Returns:
            Sequence[T]: A list of model instances.
        """
        async with self._infra.session() as session:
            stmt = select(self._model).offset(skip).limit(limit)
            result = await session.execute(stmt)
            return result.scalars().all()

    async def create(self, obj: T) -> T:
        """
        Persist a new record in the database.

        Args:
            obj (T): The model instance to persist.

        Returns:
            T: The persisted instance with any autogenerated fields populated.
        """
        async with self._infra.session() as session:
            session.add(obj)
            await session.flush()  # Ensure the object has its primary key before returning
            return obj

    async def update(self, id_: Id, data: Dict[str, Any]) -> bool:
        """
        Update fields of an existing record.

        Args:
            id_ (Id): The primary key of the record to update.
            data (Dict[str, Any]): A dictionary of fields to update.

        Returns:
            bool: True if the record was updated, False otherwise.
        """
        async with self._infra.session() as session:
            stmt = (
                update(self._model).where(self._model.id == id_).values(**data).execution_options(synchronize_session="fetch")
            )
            result = await session.execute(stmt)
            return result.rowcount > 0

    async def delete(self, id_: Id) -> bool:
        """
        Permanently remove a record by its primary key.

        Args:
            id_ (Id): The primary key of the record to delete.

        Returns:
            bool: True if a record was deleted, False otherwise.
        """
        async with self._infra.session() as session:
            stmt = delete(self._model).where(self._model.id == id_)
            result = await session.execute(stmt)
            return result.rowcount > 0
