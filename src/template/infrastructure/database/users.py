from datetime import datetime
from typing import Optional, Sequence, Annotated

from sqlalchemy import select, update, String, DateTime, func
from sqlalchemy.orm import Mapped, mapped_column

from template.infrastructure.database.base import AbstractDatabaseInfra, Base
from template.schemas.users import UserReadResponseSchema, UserCreateSchema, UserReadResponse, UserUpdateSchema
from template.domain.users import (
    UserAlreadyExistsException,
    UserNotFoundException,
    UserNotProvidedException,
    PasswordNotProvidedException,
    PasswordInvalidException,
    generate_password_hash,
    check_password_hash,
)


class UserModel(Base):
    __tablename__ = "users"

    id: Mapped[int] = mapped_column(
        primary_key=True,
        autoincrement=True,
    )
    username: Mapped[Annotated[str, 64]] = mapped_column(
        String(64),
        nullable=False,
        unique=True,
    )
    hashed_password: Mapped[str] = mapped_column(
        String(128),
        nullable=False,
    )
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )

    def __init__(self, username: str, raw_password: str) -> None:
        super().__init__()
        self.username = username
        self.hashed_password = generate_password_hash(raw_password)

    def check_password(self, raw_password: str) -> bool:
        """Validate a raw password against the hashed one.

        Args:
            raw_password (str): User input password.

        Returns:
            bool: True if match, else False.
        """
        return check_password_hash(self.hashed_password, raw_password)


class UserRepository:
    """Repository for user-related database operations."""

    _infra_database: AbstractDatabaseInfra

    def __init__(self, infra_database: AbstractDatabaseInfra):
        self._infra_database = infra_database

    async def get(self, id_: int) -> Optional[UserModel]:
        """
        Retrieve an UserModel by its integer ID.

        Args:
            id_ (int): primary key of the user record.

        Returns:
            Optional[UserModel]: the matching instance, or None if not found.
        """
        async with self._infra_database.session() as session:
            stmt = select(UserModel).where(UserModel.id == id_)
            result = await session.execute(stmt)
            return result.scalar_one_or_none()

    async def get_by_username(self, username: str) -> Optional[UserModel]:
        """
        Retrieve an UserModel by its name field.

        Args:
            username (str): the human-readable name of the user.

        Returns:
            Optional[UserModel]: the matching instance, or None if not found.
        """
        async with self._infra_database.session() as session:
            stmt = select(UserModel).where(UserModel.username == username)
            result = await session.execute(stmt)
            return result.scalar_one_or_none()

    async def list_all(self, skip: int = 0, limit: int = 100) -> Sequence[UserModel]:
        """
        List UserModel records, with optional pagination and active filtering.

        Args:
            skip (int): number of records to skip (for pagination).
            limit (int): maximum number of records to return.

        Returns:
            Sequence[UserModel]: list of UserModel instances.
        """
        async with self._infra_database.session() as session:
            stmt = select(UserModel)
            stmt = stmt.offset(skip).limit(limit)
            result = await session.execute(stmt)
            return result.scalars().all()

    async def create(self, user: UserModel) -> UserModel:
        """
        Insert a new UserModel into the database.

        Args:
            user (UserModel): the new user instance to persist.

        Returns:
            UserModel: the persisted instance, with autogenerated fields populated
        """
        # Add to the session and flush so that autogenerated IDs are populated
        async with self._infra_database.session() as session:
            session.add(user)
            await session.commit()
            return user

    async def update(self, user: UserModel, data: dict) -> bool:
        """
        Update fields of an existing UserModel.

        Args:
            user (UserModel): the instance to update.
            data (dict): dictionary of fields to modify.

        Returns:
            bool: True if the update was successful, False otherwise.
        """
        async with self._infra_database.session() as session:
            stmt = update(UserModel).where(UserModel.id == user.id).values(**data)

            result = await session.execute(stmt)
            await session.commit()
            await session.flush()

        # rowcount is bad typed by SQLAlchemy, so we use type: ignore
        return result.rowcount > 0  # type: ignore

    async def delete(self, user: UserModel) -> None:
        """
        Permanently remove an UserModel from the database.

        Args:
            user (UserModel): the instance to remove.
        """
        async with self._infra_database.session() as session:
            await session.delete(user)
            await session.flush()


class UserService:
    """
    Service layer for managing API keys.

    Attributes:
        _repo (UserRepository): repository for User operations.
    """

    def __init__(self, repo: UserRepository):
        self._repo = repo

    async def _get(self, user_id: int) -> UserModel:
        """
        Retrieve an User by its ID.

        Args:
            user_id (int): identifier of the user.

        Returns:
            UserReadResponseSchema: the retrieved user.

        Raises:
            UserNotFoundException: if no such user exists.
        """
        user = await self._repo.get(user_id)

        if not user:
            raise UserNotFoundException(user_id)

        return user

    async def get_by_username(self, username: str) -> UserModel:
        """
        Retrieve an User by its username.

        Args:
            username (str): the human-readable name of the user.

        Returns:
            Optional[UserModel]: the matching instance, or None if not found.
        """
        user = await self._repo.get_by_username(username)

        if not user:
            raise UserNotFoundException(username)

        return user

    async def get(self, user_id: int) -> UserReadResponseSchema:
        """
        Retrieve an User by its ID.

        Args:
            user_id (int): identifier of the user.

        Returns:
            UserReadResponseSchema: the retrieved user.

        Raises:
            UserNotFoundException: if no such user exists.
        """
        user = await self._get(user_id)
        return UserReadResponseSchema.model_validate(user)

    async def list_all(self, skip: int = 0, limit: int = 100) -> Sequence[UserReadResponseSchema]:
        """
        List Users with optional pagination and activeâ€only filtering.

        Args:
            skip (int): number of records to skip.
            limit (int): maximum number to return.

        Returns:
            List[UserOutputSchema]: list of user schemas.
        """
        users = await self._repo.list_all(
            skip=skip,
            limit=limit,
        )
        return [UserReadResponseSchema.model_validate(k) for k in users]

    async def create(self, data: UserCreateSchema) -> UserReadResponse:
        """
        Create and persist a new User.

        Args:
            data (UserCreateSchema): input data.

        Returns:
            UserCreateResponseSchema: the created user + its raw plain_user.
        """
        # Check if user already exists (handle sql integrity errors)
        if await self._repo.get_by_username(data.username):
            raise UserAlreadyExistsException(data.username)

        # Build model (generates & hashes raw_user internally)
        model = UserModel(username=data.username, raw_password=data.raw_password)

        # Persist the model
        user = await self._repo.create(model)

        # Build response schema
        return UserReadResponse.model_validate(user)

    async def update(self, id_: int, data: UserUpdateSchema) -> UserReadResponseSchema:
        """
        Update fields of an existing User.

        Args:
            id_ (int): identifier of the user.
            data (UserUpdateSchema): fields to modify.

        Returns:
            UserReadResponseSchema: updated user.

        Raises:
            UserNotFoundException: if no such user exists.
        """
        user = await self._get(id_)
        await self._repo.update(user, data.model_dump())
        return UserReadResponseSchema.model_validate(user)

    async def verify_password(self, username: str, raw_password: str):
        """
        Verify that a raw User is valid against stored hashes.

        Only active users are checked.

        Args:
            username (str): the human-readable name of the user.
            raw_password (str): the plain user to verify.

        Returns:
            bool: True if valid.

        Raises:
            UserInvalidException: if no match is found.
        """
        if not username:
            raise UserNotProvidedException()

        if not raw_password:
            raise PasswordNotProvidedException()

        user = await self.get_by_username(username)

        if not user:
            raise UserNotFoundException(username)

        if not user.check_password(raw_password):
            raise PasswordInvalidException(raw_password)

    async def delete(self, user_id: int) -> None:
        """
        Permanently delete an User by its ID.

        Args:
            user_id (int): identifier of the user to delete.

        Raises:
            UserNotFoundException: if no such user exists.
        """
        user = await self._get(user_id)
        await self._repo.delete(user)
