from datetime import datetime
from typing import Optional, Sequence, Annotated

from sqlalchemy import select, update, String, DateTime, func
from sqlalchemy.orm import Mapped, mapped_column

from template.infrastructure.database.base import AbstractDatabaseInfra, Base
from template.domain.users import (
    generate_password_hash,
    check_password_hash,
)


class UserModel(Base):
    __tablename__ = "users"

    id: Mapped[int] = mapped_column(
        primary_key=True,
        autoincrement=True,
    )
    username: Mapped[Annotated[str, 64]] = mapped_column(
        String(64),
        nullable=False,
        unique=True,
    )
    hashed_password: Mapped[str] = mapped_column(
        String(128),
        nullable=False,
    )
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )

    def __init__(self, username: str, raw_password: str) -> None:
        super().__init__()
        self.username = username
        self.hashed_password = generate_password_hash(raw_password)

    def check_password(self, raw_password: str) -> bool:
        """Validate a raw password against the hashed one.

        Args:
            raw_password (str): User input password.

        Returns:
            bool: True if match, else False.
        """
        return check_password_hash(self.hashed_password, raw_password)


class UserRepository:
    """Repository for user-related database operations."""

    _infra_database: AbstractDatabaseInfra

    def __init__(self, infra_database: AbstractDatabaseInfra):
        self._infra_database = infra_database

    async def get(self, id_: int) -> Optional[UserModel]:
        """
        Retrieve an UserModel by its integer ID.

        Args:
            id_ (int): primary key of the user record.

        Returns:
            Optional[UserModel]: the matching instance, or None if not found.
        """
        async with self._infra_database.get_session() as session:
            stmt = select(UserModel).where(UserModel.id == id_)
            result = await session.execute(stmt)
            return result.scalar_one_or_none()

    async def get_by_username(self, username: str) -> Optional[UserModel]:
        """
        Retrieve an UserModel by its name field.

        Args:
            username (str): the human-readable name of the user.

        Returns:
            Optional[UserModel]: the matching instance, or None if not found.
        """
        async with self._infra_database.get_session() as session:
            stmt = select(UserModel).where(UserModel.username == username)
            result = await session.execute(stmt)
            return result.scalar_one_or_none()

    async def list_all(self, skip: int = 0, limit: int = 100) -> Sequence[UserModel]:
        """
        List UserModel records, with optional pagination and active filtering.

        Args:
            skip (int): number of records to skip (for pagination).
            limit (int): maximum number of records to return.

        Returns:
            Sequence[UserModel]: list of UserModel instances.
        """
        async with self._infra_database.get_session() as session:
            stmt = select(UserModel)
            stmt = stmt.offset(skip).limit(limit)
            result = await session.execute(stmt)
            return result.scalars().all()

    async def create(self, user: UserModel) -> UserModel:
        """
        Insert a new UserModel into the database.

        Args:
            user (UserModel): the new user instance to persist.

        Returns:
            UserModel: the persisted instance, with autogenerated fields populated
        """
        # Add to the session and flush so that autogenerated IDs are populated
        async with self._infra_database.get_session() as session:
            session.add(user)
            await session.commit()
            return user

    async def update(self, user: UserModel, data: dict) -> bool:
        """
        Update fields of an existing UserModel.

        Args:
            user (UserModel): the instance to update.
            data (dict): dictionary of fields to modify.

        Returns:
            bool: True if the update was successful, False otherwise.
        """
        async with self._infra_database.get_session() as session:
            stmt = update(UserModel).where(UserModel.id == user.id).values(**data)

            result = await session.execute(stmt)
            await session.commit()
            await session.flush()

        # rowcount is bad typed by SQLAlchemy, so we use type: ignore
        return result.rowcount > 0  # type: ignore

    async def delete(self, user: UserModel) -> None:
        """
        Permanently remove an UserModel from the database.

        Args:
            user (UserModel): the instance to remove.
        """
        async with self._infra_database.get_session() as session:
            await session.delete(user)
            await session.flush()
