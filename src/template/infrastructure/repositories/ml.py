from __future__ import annotations

from datetime import datetime
from typing import Optional

from sqlalchemy import String, func, DateTime, select, update
from sqlalchemy.orm import Mapped, mapped_column

from template.domain.ml import AbstractModelBlob, MLMeta
from template.infrastructure.database.base import Base, AbstractDatabaseInfra
from template.infrastructure.storage.base import AbstractStorageInfra
from template.infrastructure.storage.local import PickleRepository


class ModelMLMeta(Base):
    """Metadata for NLP models, used for persistence in the database."""

    __tablename__ = "models"

    id_: Mapped[str] = mapped_column(
        String(64),
        primary_key=True,
        autoincrement=False,
    )
    version: Mapped[str] = mapped_column(
        String(16),
        nullable=False,
        default="1.0.0",
    )
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )


def to_domain(row: ModelMLMeta) -> MLMeta:
    """
    Convert a database row to a domain ModelMeta instance.

    Args:
        row (ModelMLMeta): The database row to convert.

    Returns:
        MLMeta: The converted domain object.
    """
    return MLMeta.model_validate(row)


def to_row(model: MLMeta) -> ModelMLMeta:
    """
    Convert a domain ModelMeta instance to a database row.

    Args:
        model (MLMeta): The domain object to convert.

    Returns:
        ModelMLMeta: The converted database row.
    """
    return ModelMLMeta(
        id_=model.id_,
        version=model.version,
        created_at=model.created_at,
    )


class MLMetaRepository:
    """Repository for user-related database operations."""

    _infra_database: AbstractDatabaseInfra

    def __init__(self, infra_database: AbstractDatabaseInfra):
        self._infra_database = infra_database

    async def get(self, id_: str) -> Optional[MLMeta]:
        """
        Retrieve an ModelML by its integer ID.

        Args:
            id_ (int): primary key of the user record.

        Returns:
            Optional[MLMeta]: the matching instance, or None if not found.
        """
        async with self._infra_database.get_session() as session:
            stmt = select(ModelMLMeta).where(ModelMLMeta.id_ == id_)
            result = await session.execute(stmt)
            row = result.scalar_one_or_none()

            if row is None:
                return None

            return to_domain(row)

    async def create(self, model: MLMeta) -> MLMeta:
        """
        Insert a new ModelML into the database.

        Args:
            model (ModelMLMeta): the new model instance to persist.

        Returns:
            ModelMLMeta: the persisted instance, with autogenerated fields populated
        """
        row = to_row(model)
        # Add to the session and flush so that autogenerated IDs are populated
        async with self._infra_database.get_session() as session:
            session.add(row)
            await session.commit()
            return to_domain(row)

    async def update(self, model: MLMeta) -> bool:
        """
        Update fields of an existing ModelML.

        Args:
            model (ModelMLMeta): the instance to update.

        Returns:
            bool: True if the update was successful, False otherwise.
        """
        row = to_row(model)
        async with self._infra_database.get_session() as session:
            stmt = update(ModelMLMeta).where(ModelMLMeta.id_ == row.id_).values(version=row.version, created_at=row.created_at)
            result = await session.execute(stmt)
            await session.commit()

            # rowcount is bad typed by SQLAlchemy, so we use type: ignore
            return result.rowcount > 0  # type: ignore

    async def delete(self, id_: str) -> bool:
        """
        Permanently remove an ModelML from the database.

        Args:
            id_ (str): the unique identifier of the model to delete.
        """
        async with self._infra_database.get_session() as session:
            stmt = select(ModelMLMeta).where(ModelMLMeta.id_ == id_)
            result = await session.execute(stmt)
            model = result.scalar_one_or_none()

            if model is None:
                return False

            await session.delete(model)
            await session.commit()

            # rowcount is bad typed by SQLAlchemy, so we use type: ignore
            return True

    async def list_all(self, skip: int = 0, limit: int = 100) -> list[MLMeta]:
        """
        List ModelML records, with optional pagination and active filtering.

        Args:
            skip (int): number of records to skip (for pagination).
            limit (int): maximum number of records to return.

        Returns:
            Sequence[ModelML]: list of ModelML instances.
        """
        async with self._infra_database.get_session() as session:
            stmt = select(ModelMLMeta)
            stmt = stmt.offset(skip).limit(limit)
            result = await session.execute(stmt)
            return [to_domain(row) for row in result.scalars().all()]


class MLBlobRepository(PickleRepository[AbstractModelBlob]):
    """Base class for machine learning model blobs, used for serialization."""

    def __init__(self, infra_storage: AbstractStorageInfra) -> None:
        super().__init__(
            infra_storage,
            type_object=AbstractModelBlob,
            prefix="models/",
        )


"""
class MLRepository(PickleRepository[NLPModel]):
    \"""Repository for persisting machine learning models as pickled files.\"""

    def __init__(self, infra_client: AbstractStorageInfra) -> None:
        super().__init__(
            infra_client,
            type_object=Tokenizer,
            prefix="models/",
        )
"""
